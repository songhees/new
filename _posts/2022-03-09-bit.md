---
title: "비트 연산자"
excerpt: "비트 연산자란 무엇일까?"
categories: algorithm
tags: algorithm
last-modified-at: {{ page.last_modified_at }}
---

### 비트 연산자란?

> 10진수 데이터를 2진수로 계산하는 연산자다.
  
+ 컴퓨터는 전기적 신호로 정보를 전달하므로 전류가 흐르는 스위치인 on(1)/off(0)로 신호를 전달한다.
+ 2진수는 0과 1로 표현된다.  
+ 표현되는 하나의 값을 비트라고 하며 비트(bit) 8개를 바이트(byte)라고 한다.
    + 1byte는 의미있는 정보 하나를 표현한는 최소단위!  

<br/>

### bit의 구성

+ 맨 앞의 비트를 최상위 비트(Most Significant Bit, MSB)라고 표현한다.  
    **signed bit** = MSB가 부호를 나타내는 경우
    + 0은 **양수**  
    + 1은 **음수**  

    **unsigned bit** = 그렇지 않는 경우 
<br/>
  
+ 맨 뒤의 비트를 Least Significant Bit(LSB)라고 한다.
2^0에 위치하므로 데이터에 들어있는 숫자가 짝수인지 홀수인지 알아낼 수 있다.  
<br/>
  
+ n bit일 경우
2^n개의 값을 저장할 수 있다.
최대값 = **2^(n-1)-1**
최소값 = **-2^(n-1)**

###### ex)
```
4bit일 경우
2^4개의 값을 저장할 수 있다. 그 중에 MSB이 부호를 나타낸다.
최대값은 2^3-1 = 7
최소값은 -2^3 = -8
```
<br/>  

### 비트 덧셈

10진수와 같이 10보다 크면 올림과 같이
2진수는 합쳤을 때 2보다 크면 1을 올린다.
음수 끼리의 덧셈도 마찬가지다.
**두 수의 MSB가 같으면 결과값도 MSB가 같기 때문에 문제 없다.**
<br/>

### 비트 뺄셈
  
부호가 **서로다른** 덧셈에서는??  
컴퓨터는 덧셈만 가능하므로 뺄셈은 보수를 이용해 덧셈으로 바꾼다. 
*2 - 3*을 *2 + (-3)[3의 보수]* 으로 바꿈
  
음수와 양수의 계산에서 **보수**(보충해주는 수) 라는 개념이 나온다.  
n진수에 대해서 n의 보수와 n-1의 보수가 존재한다.
 
2진수에서 2의 보수는 두 수를 더하게 되면 최대 비트 크기보다 크면서 가장 작은 2의 거듭제곱 수가 나온다.
  
<br/>

- - -
~연산자는 1의 보수로 변환 시키는 것이다.
예를 들어
2의 ~2값은 -3이다.
0010 => 1101  
맨 앞의 MSB는 1이므로 음수이고, 음수일 경우 양수에서 읽는 것과 반대로 읽으면 
0이 2의 값이고 양수와 달리 음수는 0이 존재하지 않으므로 
2보다 +1 한 3값이고 음수이므로 -3이 된다.

2에 대한 1의 보수는 1101으로 -3이고
2에 대한 2의 보수는 1110으로 -2이다.

2+(-2)는 
```
    0010
+   1110
--------
   10000
```
으로 최대 비트 크기보다 크면서 가장 작은 2의 거듭제곱 수가 나온다.
- - -

### 비트 연산

##### AND
```
    xxxx    xxxx    xxxx
&   1111    0000    xxxx
--------- ------- -------
    xxxx    0000    xxxx
```

##### OR
```
    xxxx    xxxx    xxxx
|   1111    0000    xxxx
--------- ------- -------
    1111    xxxx    xxxx
```

##### XOR
> 다른 값이면 1
 같은 값이면 0
```
    xxxx    xxxx    xxxx
^   1111    0000    xxxx
--------- ------- -------
  ~ xxxx    xxxx    0000
```

